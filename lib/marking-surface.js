// Generated by CoffeeScript 1.6.3
(function() {
  var BaseClass, CASE_SENSITIVE_ATTRIBUTES, ElementBase, FILTER_ID_PREFIX, KEYS, Mark, MarkingSurface, NAMESPACES, NON_ATTRIBUTE_PROPERTIES, SVG, Tool, ToolControls, ToolFocusTarget, focusFilter, focusMerge, insertStyle, invertFilter, invertTransfer, matchesSelector, shadowFilter, shadowMerge, _ref,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  matchesSelector = (function() {
    var MATCHES_SELECTOR, MATCH_METHODS, method, _i, _len;
    MATCH_METHODS = ['mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector', 'webkitMatchesSelector', 'matchesSelector', 'matches'];
    for (_i = 0, _len = MATCH_METHODS.length; _i < _len; _i++) {
      method = MATCH_METHODS[_i];
      if (method in Element.prototype) {
        MATCHES_SELECTOR = method;
      }
    }
    return function(el, selector) {
      return typeof el[MATCHES_SELECTOR] === "function" ? el[MATCHES_SELECTOR](selector) : void 0;
    };
  })();

  insertStyle = (function() {
    var IE_HACK_ID;
    IE_HACK_ID = 'marking-surface-element-that-only-exists-to-please-ie';
    return function(id, styleContent) {
      var ieHackElement;
      document.querySelector('style, link[rel="stylesheet"]').insertAdjacentHTML('beforeBegin', "<span id=\"" + IE_HACK_ID + "\"></span>\n<style id=\"" + id + "\">" + styleContent + "</style>");
      ieHackElement = document.getElementById(IE_HACK_ID);
      ieHackElement.parentNode.removeChild(ieHackElement);
      return document.getElementById(id);
    };
  })();

  BaseClass = (function() {
    function BaseClass(params) {
      var property, value;
      if (params == null) {
        params = {};
      }
      this._events = {};
      for (property in params) {
        value = params[property];
        this[property] = value;
      }
    }

    BaseClass.prototype.on = function(eventName, handler) {
      var _base;
      if ((_base = this._events)[eventName] == null) {
        _base[eventName] = [];
      }
      return this._events[eventName].push(handler);
    };

    BaseClass.prototype.trigger = function(eventName, args) {
      var handler, _i, _len, _ref, _results;
      if (args == null) {
        args = [];
      }
      if (eventName in this._events) {
        _ref = this._events[eventName];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          handler = _ref[_i];
          _results.push(this.applyHandler(handler, args));
        }
        return _results;
      }
    };

    BaseClass.prototype.applyHandler = function(handler, givenArgs) {
      var context, firstArgs, _ref;
      if (givenArgs == null) {
        givenArgs = [];
      }
      context = this;
      if (handler instanceof Array) {
        _ref = handler, context = _ref[0], handler = _ref[1], firstArgs = 3 <= _ref.length ? __slice.call(_ref, 2) : [];
      }
      if (firstArgs == null) {
        firstArgs = [];
      }
      if (typeof handler === 'string') {
        handler = context[handler];
      }
      return handler.call.apply(handler, [context].concat(__slice.call(firstArgs), __slice.call(givenArgs)));
    };

    BaseClass.prototype.off = function(eventName, handler) {
      var handlerIndex, handlerList, property, _results;
      if (eventName != null) {
        if (eventName in this._events) {
          handlerList = this._events[eventName];
          if (handler != null) {
            handlerIndex = handlerList.indexOf(handler);
            return handlerList.splice(handlerIndex, 1);
          } else {
            return handlerList.splice(0);
          }
        }
      } else {
        _results = [];
        for (property in this._events) {
          _results.push(delete this._events[property]);
        }
        return _results;
      }
    };

    BaseClass.prototype.destroy = function() {
      this.trigger('destroy');
      return setTimeout(function() {
        return this.off();
      });
    };

    return BaseClass;

  })();

  ElementBase = (function(_super) {
    __extends(ElementBase, _super);

    ElementBase.prototype.tag = 'div';

    ElementBase.prototype.disabled = false;

    ElementBase.prototype._startEvent = null;

    function ElementBase() {
      this._eventListeners = {};
      this._delegatedListeners = {};
      ElementBase.__super__.constructor.apply(this, arguments);
      if (this.el == null) {
        this._createEl();
      }
      this.addEvent('mousedown', this._onStart);
      this.addEvent('touchstart', this._onStart);
      if (this.disabled) {
        this.disable();
      }
    }

    ElementBase.prototype._createEl = function() {
      var classNames, tagName, _ref;
      _ref = this.tag.split('.'), tagName = _ref[0], classNames = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
      this.el = document.createElement(tagName);
      return this.el.className = classNames.join(' ');
    };

    ElementBase.prototype.attr = function(attribute, value) {
      if (arguments.length === 1) {
        this.el.getAttribute(attribute);
      } else {
        if (value != null) {
          this.el.setAttribute(attribute, value);
        } else {
          this.el.removeAttribute(attribute);
        }
      }
      if ('msMatchesSelector' in document.body) {
        this.el.style.display = 'none';
        return this.el.style.display = '';
      }
    };

    ElementBase.prototype.enable = function(e) {
      this.disabled = false;
      this.attr('disabled', null);
      return this.trigger('enable');
    };

    ElementBase.prototype.disable = function(e) {
      this.disabled = true;
      this.attr('disabled', true);
      return this.trigger('disable');
    };

    ElementBase.prototype.addEvent = function() {
      var delegate, eventName, handler, _arg, _base, _base1, _base2, _i;
      eventName = arguments[0], _arg = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), handler = arguments[_i++];
      delegate = _arg[0];
      if (!(eventName in this._eventListeners || eventName in this._delegatedListeners)) {
        this.el.addEventListener(eventName, this, false);
      }
      if (delegate != null) {
        if ((_base = this._delegatedListeners)[eventName] == null) {
          _base[eventName] = {};
        }
        if ((_base1 = this._delegatedListeners[eventName])[delegate] == null) {
          _base1[delegate] = [];
        }
        return this._delegatedListeners[eventName][delegate].push(handler);
      } else {
        if ((_base2 = this._eventListeners)[eventName] == null) {
          _base2[eventName] = [];
        }
        return this._eventListeners[eventName].push(handler);
      }
    };

    ElementBase.prototype._onStart = function(e) {
      this._startEvent = e;
      addEventListener('mousemove', this, false);
      addEventListener('mouseup', this, false);
      addEventListener('touchmove', this, false);
      addEventListener('touchend', this, false);
      addEventListener('touchcancel', this, false);
      return this.dispatchEvent('start', {
        originalEvent: e
      });
    };

    ElementBase.prototype._onMove = function(e) {
      return this.dispatchEvent('move', {
        originalEvent: e
      });
    };

    ElementBase.prototype._onRelease = function(e) {
      removeEventListener('mousemove', this, false);
      removeEventListener('mouseup', this, false);
      removeEventListener('touchmove', this, false);
      removeEventListener('touchend', this, false);
      removeEventListener('touchcancel', this, false);
      this._startEvent = null;
      return this.dispatchEvent('release', {
        originalEvent: e
      });
    };

    ElementBase.prototype.handleEvent = function(e) {
      var handler, handlers, match, moveTarget, selector, target, type, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results;
      if (!this.disabled) {
        if (e.currentTarget === window) {
          switch (e.type) {
            case 'mousemove':
            case 'touchmove':
              return this._onMove(e);
            case 'mouseup':
            case 'touchend':
            case 'touchcancel':
              return this._onRelease(e);
          }
        } else {
          type = e.type;
          if ((_ref = e.detail) != null ? _ref.originalEvent : void 0) {
            e = e.detail.originalEvent;
            moveTarget = (_ref1 = (_ref2 = this._startEvent) != null ? _ref2.target : void 0) != null ? _ref1 : (_ref3 = this._startEvent) != null ? _ref3.srcElement : void 0;
          }
          if (type in this._eventListeners) {
            _ref4 = this._eventListeners[type];
            for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
              handler = _ref4[_i];
              this.applyHandler(handler, [e]);
            }
          }
          if (type in this._delegatedListeners) {
            _ref5 = this._delegatedListeners[type];
            _results = [];
            for (selector in _ref5) {
              handlers = _ref5[selector];
              match = null;
              target = (_ref6 = moveTarget != null ? moveTarget : e.target) != null ? _ref6 : e.srcElement;
              while ((target != null) && (match == null)) {
                if (matchesSelector(target, selector)) {
                  match = target;
                }
                target = target.parentNode;
              }
              if (match != null) {
                _results.push((function() {
                  var _j, _len1, _results1;
                  _results1 = [];
                  for (_j = 0, _len1 = handlers.length; _j < _len1; _j++) {
                    handler = handlers[_j];
                    _results1.push(this.applyHandler(handler, [e]));
                  }
                  return _results1;
                }).call(this));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        }
      }
    };

    ElementBase.prototype.removeEvent = function() {
      var delegate, eventName, handler, handlers, index, _arg, _i;
      eventName = arguments[0], _arg = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), handler = arguments[_i++];
      delegate = _arg[0];
      handlers = delegate != null ? eventName in this._delegatedListeners ? delegate in this._delegatedListeners[eventName] ? __indexOf.call(this._delegatedListeners[eventName], handler) >= 0 ? this._delegatedListeners[eventName] : void 0 : void 0 : void 0 : eventName in this._eventListeners ? __indexOf.call(this._eventListeners[eventName], handler) >= 0 ? this._eventListeners[eventName] : void 0 : void 0;
      if (handlers != null) {
        index = handlers.indexOf(handler);
        return handlers.splice(index, 1);
      }
    };

    ElementBase.prototype.dispatchEvent = function(eventName, detail) {
      var e;
      e = document.createEvent('CustomEvent');
      e.initCustomEvent(eventName, true, true, detail);
      return this.el.dispatchEvent(e);
    };

    ElementBase.prototype.trigger = function(eventName, args) {
      if (args == null) {
        args = [];
      }
      ElementBase.__super__.trigger.apply(this, arguments);
      return this.dispatchEvent(eventName, [this].concat(__slice.call(args)));
    };

    ElementBase.prototype.pointerOffset = function(e) {
      var left, top, x, y, _ref;
      if ('touches' in e) {
        e = e.touches[0];
      }
      _ref = this.el.getBoundingClientRect(), left = _ref.left, top = _ref.top;
      x = e.pageX - pageXOffset - left;
      y = e.pageY - pageYOffset - top;
      return {
        x: x,
        y: y
      };
    };

    ElementBase.prototype.toFront = function() {
      var _ref;
      return (_ref = this.el.parentNode) != null ? _ref.appendChild(this.el) : void 0;
    };

    ElementBase.prototype.remove = function() {
      var _ref;
      return (_ref = this.el.parentNode) != null ? _ref.removeChild(this.el) : void 0;
    };

    ElementBase.prototype.destroy = function() {
      var eventName;
      ElementBase.__super__.destroy.apply(this, arguments);
      this.remove();
      for (eventName in this._eventListeners) {
        this.el.removeEventListener(eventName, this, false);
      }
      for (eventName in this._delegatedListeners) {
        if (eventName in this._eventListeners) {
          continue;
        }
        this.el.removeEventListener(eventName, this, false);
      }
      this._eventListeners = {};
      return this._delegatedListeners = {};
    };

    return ElementBase;

  })(BaseClass);

  NAMESPACES = {
    svg: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink'
  };

  CASE_SENSITIVE_ATTRIBUTES = ['markerHeight', 'markerWidth', 'preserveAspectRatio', 'refX', 'refY', 'stdDeviation', 'tableValues', 'viewBox'];

  NON_ATTRIBUTE_PROPERTIES = ['textContent'];

  FILTER_ID_PREFIX = 'marking-surface-filter-';

  SVG = (function(_super) {
    __extends(SVG, _super);

    SVG.prototype.tag = 'svg';

    SVG.prototype.defaultAttrs = null;

    function SVG() {
      SVG.__super__.constructor.apply(this, arguments);
      if (this.defaultAttrs != null) {
        this.attr(this.defaultAttrs);
        this.defaultAttrs = null;
      }
    }

    SVG.prototype._createEl = function() {
      var classNames, namespace, tagName, _i, _ref, _ref1;
      _ref = this.tag.split('.'), tagName = _ref[0], classNames = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
      tagName || (tagName = 'svg');
      _ref1 = tagName.split(':'), namespace = 2 <= _ref1.length ? __slice.call(_ref1, 0, _i = _ref1.length - 1) : (_i = 0, []), tagName = _ref1[_i++];
      namespace = namespace.join(':') || 'svg';
      this.el = document.createElementNS(NAMESPACES[namespace] || null, tagName);
      return this.attr('class', classNames.join(' '));
    };

    SVG.prototype.attr = function(attribute, value) {
      var attributes, namespace, _i, _ref, _ref1, _results;
      if (typeof attribute === 'string') {
        if (!(__indexOf.call(CASE_SENSITIVE_ATTRIBUTES, attribute) >= 0 || __indexOf.call(NON_ATTRIBUTE_PROPERTIES, attribute) >= 0)) {
          attribute = (attribute.replace(/([A-Z])/g, '-$1')).toLowerCase();
        }
        _ref = attribute.split(':'), namespace = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), attribute = _ref[_i++];
        namespace = (_ref1 = NAMESPACES[namespace.join('')]) != null ? _ref1 : null;
        if (arguments.length === 1) {
          if (__indexOf.call(NON_ATTRIBUTE_PROPERTIES, attribute) >= 0) {
            return this.el[attribute];
          } else {
            return this.el.getAttributeNS(namespace, attribute);
          }
        } else {
          if (value != null) {
            if (__indexOf.call(NON_ATTRIBUTE_PROPERTIES, attribute) >= 0) {
              return this.el[attribute] = value;
            } else {
              return this.el.setAttributeNS(namespace, attribute, value);
            }
          } else {
            return this.el.removeAttributeNS(namespace, attribute);
          }
        }
      } else {
        attributes = attribute;
        _results = [];
        for (attribute in attributes) {
          value = attributes[attribute];
          _results.push(this.attr(attribute, value));
        }
        return _results;
      }
    };

    SVG.prototype.addShape = function(tag, defaultAttrs) {
      var shape;
      shape = new SVG({
        tag: tag,
        defaultAttrs: defaultAttrs
      });
      this.el.appendChild(shape.el);
      return shape;
    };

    SVG.prototype.filter = function(name) {
      return this.attr('filter', name != null ? "url(#" + FILTER_ID_PREFIX + name + ")" : '');
    };

    return SVG;

  })(ElementBase);

  SVG.filtersContainer = new SVG({
    defaultAttrs: {
      id: 'marking-surface-filters-container',
      width: 0,
      height: 0,
      style: 'bottom: 0; position: absolute; right: 0;'
    }
  });

  SVG.filterDefs = SVG.filtersContainer.addShape('defs');

  shadowFilter = SVG.filterDefs.addShape('filter', {
    id: "" + FILTER_ID_PREFIX + "shadow"
  });

  shadowFilter.addShape('feGaussianBlur', {
    stdDeviation: 2,
    "in": 'SourceAlpha'
  });

  shadowFilter.addShape('feOffset', {
    dx: 0.5,
    dy: 1
  });

  shadowMerge = shadowFilter.addShape('feMerge');

  shadowMerge.addShape('feMergeNode');

  shadowMerge.addShape('feMergeNode', {
    "in": 'SourceGraphic'
  });

  focusFilter = SVG.filterDefs.addShape('filter', {
    id: "" + FILTER_ID_PREFIX + "focus"
  });

  focusFilter.addShape('feGaussianBlur', {
    stdDeviation: 3
  });

  focusMerge = focusFilter.addShape('feMerge');

  focusMerge.addShape('feMergeNode');

  focusMerge.addShape('feMergeNode', {
    "in": 'SourceGraphic'
  });

  invertFilter = SVG.filterDefs.addShape('filter', {
    id: "" + FILTER_ID_PREFIX + "invert",
    colorInterpolationFilters: 'sRGB'
  });

  invertTransfer = invertFilter.addShape('feComponentTransfer');

  invertTransfer.addShape('feFuncR', {
    type: 'table',
    tableValues: '1 0'
  });

  invertTransfer.addShape('feFuncG', {
    type: 'table',
    tableValues: '1 0'
  });

  invertTransfer.addShape('feFuncB', {
    type: 'table',
    tableValues: '1 0'
  });

  document.body.appendChild(SVG.filtersContainer.el);

  Mark = (function(_super) {
    __extends(Mark, _super);

    function Mark() {
      _ref = Mark.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Mark.prototype.precision = 3;

    Mark.prototype.ignore = ['disabled', 'ignore', 'precision'];

    Mark.prototype.set = function(property, value) {
      var properties, setter;
      if (typeof property === 'string') {
        setter = this["set " + property];
        if (setter != null) {
          value = setter.call(this, value);
        }
        this[property] = value;
        this.trigger('change', [property, value]);
      } else {
        properties = property;
        for (property in properties) {
          value = properties[property];
          this.set(property, value);
        }
      }
    };

    Mark.prototype.toJSON = function() {
      var parts, property, result, value;
      result = {};
      for (property in this) {
        value = this[property];
        if (__indexOf.call(this.ignore, property) >= 0) {
          continue;
        }
        if (property.charAt(0) === '_') {
          continue;
        }
        if (typeof value === 'number') {
          parts = value.toString().split('.');
          if (parts[1] != null) {
            parts[1] = parts[1].slice(0, this.precision);
            value = parseFloat(parts.join('.'));
          }
        }
        result[property] = value;
      }
      return result;
    };

    return Mark;

  })(BaseClass);

  KEYS = {
    esc: 27,
    "delete": 8
  };

  ToolFocusTarget = (function(_super) {
    __extends(ToolFocusTarget, _super);

    ToolFocusTarget.prototype.tag = 'button.marking-surface-tool-focus-target';

    function ToolFocusTarget() {
      ToolFocusTarget.__super__.constructor.apply(this, arguments);
      this.el.type = 'button';
      this.tool.on('focus', [this.el, 'focus']);
      this.tool.on('select', [this, 'toFront']);
      this.tool.on('destroy', [this, 'destroy']);
      this.addEvent('focus', [this.tool, 'focus']);
      this.addEvent('click', [this.tool, 'select']);
      this.addEvent('blur', [this.tool, 'blur']);
      this.addEvent('keydown', this.onKeydown);
    }

    ToolFocusTarget.prototype.onKeydown = function(e) {
      var index, next, noShortcutCalled, siblingFocusTargets, _ref1;
      if (e.metaKey || e.ctrlKey || e.altKey) {
        return;
      }
      switch (e.which) {
        case KEYS["delete"]:
          siblingFocusTargets = this.el.parentNode.children;
          index = Array.prototype.indexOf.call(siblingFocusTargets, this.el);
          this.tool.mark.destroy();
          next = siblingFocusTargets[index % siblingFocusTargets.length];
          if (next != null) {
            next.focus();
          }
          break;
        case KEYS.esc:
          if ((_ref1 = this.tool.markingSurface.selection) != null) {
            _ref1.deselect();
          }
          break;
        default:
          noShortcutCalled = true;
      }
      if (!noShortcutCalled) {
        return e.preventDefault();
      }
    };

    return ToolFocusTarget;

  })(ElementBase);

  ToolControls = (function(_super) {
    __extends(ToolControls, _super);

    ToolControls.prototype.tag = 'div.marking-surface-tool-controls';

    ToolControls.prototype.template = '';

    function ToolControls() {
      ToolControls.__super__.constructor.apply(this, arguments);
      this.el.insertAdjacentHTML('beforeEnd', this.template);
      this.tool.on('select', [this, 'onToolSelect']);
      this.tool.mark.on('change', [this, 'onMarkChange']);
      this.tool.on('deselect', [this, 'onToolDeselect']);
      this.tool.on('destroy', [this, 'onToolDestroy']);
    }

    ToolControls.prototype.onToolSelect = function() {
      this.toFront();
      return this.attr('data-selected', true);
    };

    ToolControls.prototype.onToolDeselect = function() {
      return this.attr('data-selected', null);
    };

    ToolControls.prototype.onToolDestroy = function() {
      return this.destroy();
    };

    ToolControls.prototype.onMarkChange = function() {
      return typeof this.render === "function" ? this.render.apply(this, arguments) : void 0;
    };

    ToolControls.prototype.moveTo = function(_arg) {
      var height, outOfBounds, width, x, y, _ref1;
      x = _arg.x, y = _arg.y;
      _ref1 = this.tool.markingSurface.toPixels({
        x: x,
        y: y
      }), x = _ref1.x, y = _ref1.y;
      width = this.tool.markingSurface.el.offsetWidth;
      height = this.tool.markingSurface.el.offsetHeight;
      outOfBounds = x < 0 || x > width || y < 0 || y > height;
      this.attr('data-out-of-bounds', outOfBounds || null);
      this.el.style.left = "" + x + "px";
      this.el.style.top = "" + y + "px";
      this.attr('data-horizontal-room', x < width / 2 ? 'right' : 'left');
      return this.attr('data-vertical-room', y < height / 2 ? 'down' : 'up');
    };

    ToolControls.prototype.render = function() {
      return this.attr('data-complete', this.tool.isComplete() || null);
    };

    return ToolControls;

  })(ElementBase);

  ToolControls.defaultStyle = insertStyle('marking-surface-tool-controls-default-style', '.marking-surface-tool-controls {\n  position: absolute;\n}\n\n.marking-surface-tool-controls:not([data-selected]) {\n  display: none;\n}\n\n.marking-surface-tool-controls[data-out-of-bounds] {\n  display: none;\n}');

  Tool = (function(_super) {
    __extends(Tool, _super);

    Tool.Mark = Mark;

    Tool.Controls = null;

    Tool.mobile = !!navigator.userAgent.match(/iP|droid/);

    Tool.prototype.tag = 'g.marking-surface-tool';

    Tool.prototype.markingSurface = null;

    Tool.prototype.movements = 0;

    function Tool() {
      var _this = this;
      Tool.__super__.constructor.apply(this, arguments);
      if (this.mark == null) {
        this.mark = new this.constructor.Mark;
        this.trigger('create-mark', [this.mark]);
      }
      this.mark.on('change', [this, 'onMarkChange']);
      this.mark.on('destroy', [this, 'onMarkDestroy']);
      if (this.constructor.Controls != null) {
        this.controls = new this.constructor.Controls({
          tool: this
        });
        this.trigger('create-controls', [this.controls]);
      }
      this.focusTarget = new ToolFocusTarget({
        tool: this
      });
      this.focusRoot = SVG.prototype.addShape.call(this, 'g.marking-surface-tool-focus-root');
      this.selectedRoot = this.focusRoot.addShape('g.marking-surface-tool-selected-root');
      this.root = this.selectedRoot.addShape('g.marking-surface-tool-root');
      setTimeout(function() {
        if (_this.markingSurface != null) {
          return _this.rescale(_this.markingSurface.getScale());
        }
      });
    }

    Tool.prototype.onMarkChange = function(property, value) {
      var _name, _ref1, _ref2, _ref3;
      if (typeof this.render === "function") {
        this.render(property, value);
      }
      if ((_ref1 = this.render) != null) {
        if ((_ref2 = _ref1[property]) != null) {
          if (typeof _ref2.call === "function") {
            _ref2.call(this, value);
          }
        }
      }
      if (typeof this[_name = (_ref3 = this.render) != null ? _ref3[property] : void 0] === "function") {
        this[_name]();
      }
      return this.trigger('change', [this.mark]);
    };

    Tool.prototype.onMarkDestroy = function() {
      return this.destroy();
    };

    Tool.prototype.addShape = function() {
      var _ref1;
      return (_ref1 = this.root).addShape.apply(_ref1, arguments);
    };

    Tool.prototype.coords = function(e) {
      return this.markingSurface.toScale(this.markingSurface.sizeRect.pointerOffset(e));
    };

    Tool.prototype._onStart = function(e) {
      e.preventDefault();
      Tool.__super__._onStart.apply(this, arguments);
      this.select();
      return this.focus();
    };

    Tool.prototype.handleEvent = function() {
      if (!this.markingSurface.disabled) {
        return Tool.__super__.handleEvent.apply(this, arguments);
      }
    };

    Tool.prototype.onInitialStart = function(e) {
      this.focus();
      return this.trigger('initial-click', [e]);
    };

    Tool.prototype.onInitialMove = function(e) {
      return this.trigger('initial-drag', [e]);
    };

    Tool.prototype.onInitialRelease = function(e) {
      this.movements += 1;
      return this.trigger('initial-release', [e]);
    };

    Tool.prototype.render = function() {};

    Tool.prototype.rescale = function(scaleX, scaleY) {
      return this.render();
    };

    Tool.prototype.isComplete = function() {
      return this.movements === 1;
    };

    Tool.prototype.focus = function() {
      this.attr('data-focused', true);
      return this.trigger('focus');
    };

    Tool.prototype.blur = function() {
      this.attr('data-focused', null);
      return this.trigger('blur');
    };

    Tool.prototype.select = function() {
      this.attr('data-selected', true);
      this.toFront();
      return this.trigger('select');
    };

    Tool.prototype.deselect = function() {
      this.attr('data-selected', null);
      return this.trigger('deselect');
    };

    Tool.prototype.destroy = function() {
      this.deselect();
      return Tool.__super__.destroy.apply(this, arguments);
    };

    return Tool;

  })(SVG);

  Tool.defaultStyle = insertStyle('marking-surface-tool-default-style', ".marking-surface-tool[data-focused] .marking-surface-tool-focus-root {\n  filter: url(#" + FILTER_ID_PREFIX + "focus);\n}\n\n.marking-surface-tool[data-selected] .marking-surface-tool-selected-root {\n  filter: url(#" + FILTER_ID_PREFIX + "shadow);\n}");

  MarkingSurface = (function(_super) {
    __extends(MarkingSurface, _super);

    MarkingSurface.prototype.tag = 'div.marking-surface';

    MarkingSurface.prototype.focusable = true;

    MarkingSurface.prototype.inputName = '';

    MarkingSurface.prototype.tool = null;

    MarkingSurface.prototype.selection = null;

    function MarkingSurface() {
      this.tools = [];
      MarkingSurface.__super__.constructor.apply(this, arguments);
      this.svg = new SVG({
        tag: 'svg.marking-surface-svg'
      });
      this.sizeRect = this.svg.addShape('rect', {
        fill: 'none',
        stroke: 'transparent',
        strokeWidth: 0,
        width: '100%',
        height: '100%'
      });
      this.root = this.svg.addShape('g.marking-surface-svg-root');
      this.el.appendChild(this.svg.el);
      this.on('destroy', [this.svg, 'destroy']);
      this.svg.addEvent('select', '.marking-surface-tool', [this, 'onSelectTool']);
      this.svg.addEvent('change', '.marking-surface-tool', [this, 'onChangeMark']);
      this.svg.addEvent('deselect', '.marking-surface-tool', [this, 'onDeselectTool']);
      this.svg.addEvent('destroy', '.marking-surface-tool', [this, 'onDestroyTool']);
      if (this.focusable) {
        this.toolFocusTargetsContainer = new ElementBase({
          tag: 'div.marking-surface-tool-focusables-container'
        });
        this.el.appendChild(this.toolFocusTargetsContainer.el);
        this.on('destroy', [this.toolFocusTargetsContainer, 'destroy']);
      }
      this.toolControlsContainer = new ElementBase({
        tag: 'div.marking-surface-tool-controls-container'
      });
      this.el.appendChild(this.toolControlsContainer.el);
      this.on('destroy', [this.toolControlsContainer, 'destroy']);
      if (this.inputName) {
        this.input = new ElementBase({
          tag: 'input.marking-surface-input'
        });
        this.input.el.tabIndex = -1;
        this.input.el.name = this.inputName;
        this.on('change', this.onChange);
        this.on('destroy', [this.input, 'destroy']);
        this.el.appendChild(this.input.el);
      }
      this.trigger('change');
      addEventListener('resize', this, false);
    }

    MarkingSurface.prototype.handleEvent = function(e) {
      if (e.target === window && e.type === 'resize') {
        return this.rescaleTools();
      } else {
        return MarkingSurface.__super__.handleEvent.apply(this, arguments);
      }
    };

    MarkingSurface.prototype.addShape = function() {
      var _ref1;
      return (_ref1 = this.root).addShape.apply(_ref1, arguments);
    };

    MarkingSurface.prototype._onStart = function(e) {
      var tool, _ref1;
      if (e.defaultPrevented) {
        return;
      }
      if (matchesSelector(e.target, '.marking-surface-tool-controls-container *')) {
        return;
      }
      e.preventDefault();
      tool = (this.selection == null) || ((_ref1 = this.selection) != null ? _ref1.isComplete() : void 0) ? this.tool != null ? this.addTool() : void 0 : this.selection;
      if (tool != null) {
        tool.select();
        tool.onInitialStart(e);
        return MarkingSurface.__super__._onStart.apply(this, arguments);
      }
    };

    MarkingSurface.prototype._onMove = function(e) {
      var _ref1;
      MarkingSurface.__super__._onMove.apply(this, arguments);
      return (_ref1 = this.selection) != null ? _ref1.onInitialMove(e) : void 0;
    };

    MarkingSurface.prototype._onRelease = function(e) {
      var _ref1;
      MarkingSurface.__super__._onRelease.apply(this, arguments);
      return (_ref1 = this.selection) != null ? _ref1.onInitialRelease(e) : void 0;
    };

    MarkingSurface.prototype.addTool = function(tool) {
      var _ref1;
      if (tool == null) {
        tool = new this.tool({
          markingSurface: this
        });
      }
      tool.markingSurface = this;
      this.tools.push(tool);
      tool.remove();
      this.root.el.appendChild(tool.el);
      if (typeof tool.render === "function") {
        tool.render();
      }
      if (tool.controls != null) {
        this.toolControlsContainer.el.appendChild(tool.controls.el);
      }
      if (tool.focusTarget != null) {
        if ((_ref1 = this.toolFocusTargetsContainer) != null) {
          _ref1.el.appendChild(tool.focusTarget.el);
        }
      }
      this.trigger('add-tool', [tool]);
      this.trigger('change');
      return tool;
    };

    MarkingSurface.prototype.onSelectTool = function(e) {
      var tool, _ref1;
      tool = e.detail[0];
      if (this.selection !== tool) {
        if ((_ref1 = this.selection) != null) {
          _ref1.deselect();
        }
        this.selection = tool;
        return this.trigger('select-tool', [this.selection]);
      }
    };

    MarkingSurface.prototype.onChangeMark = function(e) {
      var mark;
      mark = e.detail[0];
      return this.trigger('change', [mark]);
    };

    MarkingSurface.prototype.onChange = function() {
      var _ref1;
      return (_ref1 = this.input) != null ? _ref1.el.value = this.getValue() : void 0;
    };

    MarkingSurface.prototype.onDeselectTool = function(e) {
      var tool;
      tool = e.detail[0];
      if (this.selection === tool) {
        this.selection = null;
        return this.trigger('deselect-tool', [tool]);
      }
    };

    MarkingSurface.prototype.onDestroyTool = function(e) {
      var index, tool;
      tool = e.detail[0];
      index = this.tools.indexOf(tool);
      this.tools.splice(index, 1);
      this.trigger('remove-tool', [tool]);
      return this.trigger('change');
    };

    MarkingSurface.prototype.toScale = function(_arg) {
      var sizeRect, viewBox, x, y;
      x = _arg.x, y = _arg.y;
      if (this.svg.el.hasAttribute('viewBox')) {
        viewBox = this.svg.el.viewBox.animVal;
        sizeRect = this.sizeRect.el.getBoundingClientRect();
        x += viewBox.x;
        x *= viewBox.width / sizeRect.width;
        y += viewBox.y;
        y *= viewBox.height / sizeRect.height;
      }
      return {
        x: x,
        y: y
      };
    };

    MarkingSurface.prototype.toPixels = function(_arg) {
      var sizeRect, viewBox, x, y;
      x = _arg.x, y = _arg.y;
      if (this.svg.el.hasAttribute('viewBox')) {
        viewBox = this.svg.el.viewBox.animVal;
        sizeRect = this.sizeRect.el.getBoundingClientRect();
        x /= viewBox.width / sizeRect.width;
        x -= viewBox.x;
        y /= viewBox.height / sizeRect.height;
        y -= viewBox.y;
      }
      return {
        x: x,
        y: y
      };
    };

    MarkingSurface.prototype.rescale = function(x, y, width, height) {
      this.svg.attr('viewBox', "" + x + " " + y + " " + width + " " + height);
      return this.rescaleTools();
    };

    MarkingSurface.prototype.rescaleTools = function() {
      var tool, _i, _len, _ref1, _results;
      _ref1 = this.tools;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tool = _ref1[_i];
        _results.push(typeof tool.rescale === "function" ? tool.rescale(this.getScale()) : void 0);
      }
      return _results;
    };

    MarkingSurface.prototype.getScale = function() {
      var scaled;
      scaled = this.toScale({
        x: 100,
        y: 100
      });
      return 2 / ((scaled.x / 100) + (scaled.y / 100));
    };

    MarkingSurface.prototype.getValue = function() {
      var tool;
      return JSON.stringify((function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.tools;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          tool = _ref1[_i];
          _results.push(tool.mark);
        }
        return _results;
      }).call(this));
    };

    MarkingSurface.prototype.disable = function(e) {
      var _ref1;
      if ((_ref1 = this.selection) != null) {
        _ref1.deselect();
      }
      return MarkingSurface.__super__.disable.apply(this, arguments);
    };

    MarkingSurface.prototype.reset = function() {
      while (this.tools.length !== 0) {
        this.tools[0].destroy();
      }
      return null;
    };

    MarkingSurface.prototype.destroy = function() {
      this.reset();
      removeEventListener('resize', this, false);
      return MarkingSurface.__super__.destroy.apply(this, arguments);
    };

    return MarkingSurface;

  })(ElementBase);

  MarkingSurface.defaultStyle = insertStyle('marking-surface-default-style', '.marking-surface {\n  display: inline-block;\n  position: relative;\n}\n\n.marking-surface-svg {\n  display: block;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  -webkit-user-select: none;\n}\n\n.marking-surface-input {\n  left: 0;\n  position: absolute;\n  opacity: 0;\n  pointer-events: none;\n  top: 0;\n}\n\n.marking-surface-tool-focusables-container {\n  height: 0;\n  left: 0;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  width: 0;\n}\n\n.marking-surface-tool-controls-container {\n  left: 0;\n  position: absolute;\n  top: 0;\n}');

  MarkingSurface.BaseClass = BaseClass;

  MarkingSurface.ElementBase = ElementBase;

  MarkingSurface.SVG = SVG;

  MarkingSurface.Mark = Mark;

  MarkingSurface.ToolFocusTarget = ToolControls;

  MarkingSurface.ToolControls = ToolControls;

  MarkingSurface.Tool = Tool;

  if (typeof window !== "undefined" && window !== null) {
    window.MarkingSurface = MarkingSurface;
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MarkingSurface;
  }

  if (typeof define === "function") {
    define(function() {
      return MarkingSurface;
    });
  }

}).call(this);
